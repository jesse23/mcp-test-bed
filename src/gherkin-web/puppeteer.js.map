{"version":3,"sources":["../src/puppeteer.ts"],"sourcesContent":["interface Locator {\n  click(): Promise<void>;\n  toBeVisible(): Promise<boolean>;\n  toContainText(text: string): Promise<boolean>;\n  fill(value: string): Promise<void>;\n}\n\ninterface Browser {\n  newPage(): Promise<Page>;\n  close(): Promise<void>;\n}\n\nconst triggerInputEvent = (element: HTMLElement, value: string): void => {\n  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(\n      window.HTMLInputElement.prototype,\n      'value'\n    )?.set;\n    nativeInputValueSetter?.call(element, value);\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n  }\n};\n\n// Element Handle implementation\nclass ElementHandle {\n  textContent: string | null;\n\n  constructor(public element: HTMLElement) {\n    if (!(element instanceof HTMLElement)) {\n      throw new Error(\"Expected an HTMLElement\");\n    }\n    this.textContent = element.textContent;\n    this.element = element;\n  }\n\n  async click(): Promise<void> {\n    this.element.click();\n  }\n\n  async type(text: string): Promise<void> {\n    triggerInputEvent(this.element, text);\n  }\n\n  async getText(): Promise<string> {\n    return this.element.innerText;\n  }\n\n  getAttribute(name: string): string | null {\n    return this.element.getAttribute(name);\n  }\n\n  dispatchEvent(event: Event): void {\n    this.element.dispatchEvent(event);\n  }\n\n  dispose(): void {\n    this.element = null as any;\n  }\n}\n\n// Page implementation\nclass Page {\n  async goto(url: string): Promise<void> {\n    console.log('page: goto', url);\n  }\n\n  async setViewport(options: { width: number; height: number }): Promise<void> {\n    console.log('page: setViewport', options);\n  }\n\n  async waitForSelector(selector: string): Promise<ElementHandle> {\n    const element = document.querySelector(selector);\n    if (!element) {\n      throw new Error(`Element not found: ${selector}`);\n    }\n    return new ElementHandle(element as HTMLElement);\n  }\n\n  async $(selector: string): Promise<ElementHandle | null> {\n    const element = document.querySelector(selector);\n    return element ? new ElementHandle(element as HTMLElement) : null;\n  }\n\n  async $eval<T>(selector: string, fn: (element: Element) => T): Promise<T> {\n    const element = document.querySelector(selector);\n    if (!element) {\n      throw new Error(`Element not found: ${selector}`);\n    }\n    return fn(element);\n  }\n\n  async evaluate<T>(fn: (() => T) | ((arg: any) => T), arg?: any): Promise<T> {\n    return arg ? fn(arg) : (fn as () => T)();\n  }\n\n  async evaluateHandle<T>(fn: () => T): Promise<ElementHandle> {\n    const result = fn();\n    if (result instanceof Element) {\n      return new ElementHandle(result as unknown as HTMLElement);\n    }\n    throw new Error('evaluateHandle must return an Element');\n  }\n\n  locator(selector: string): Locator {\n    return {\n      async click(): Promise<void> {\n        const element = document.querySelector(selector);\n        if (element instanceof HTMLElement) {\n          element.click();\n        }\n      },\n\n      async toBeVisible(): Promise<boolean> {\n        return document.querySelector(selector) !== null;\n      },\n\n      async toContainText(text: string): Promise<boolean> {\n        const element = document.querySelector(selector);\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          return element.value.includes(text);\n        }\n        return element?.textContent?.includes(text) ?? false;\n      },\n\n      async fill(value: string): Promise<void> {\n        const element = document.querySelector(selector);\n        if (element instanceof HTMLElement) {\n          triggerInputEvent(element, value);\n        }\n      }\n    };\n  }\n\n  async click(selector: string): Promise<void> {\n    return this.locator(selector).click();\n  }\n}\n\n// Expect helper\nexport const expect = (locator: Locator) => ({\n  async toBeVisible(): Promise<boolean> {\n    return locator.toBeVisible();\n  },\n\n  async toContainText(text: string): Promise<boolean> {\n    const result = await locator.toContainText(text);\n    console[result ? 'log' : 'error']('expect: toContainText result:', result);\n    return result;\n  }\n});\n\n// Export mock Puppeteer\nexport default {\n  launch: async (options?: { headless?: boolean; slowMo?: number }): Promise<Browser> => {\n    console.log('puppeteer: launch', options);\n    return {\n      async newPage(): Promise<Page> {\n        return new Page();\n      },\n      async close(): Promise<void> {\n        console.log('ðŸ§¹ Cleaned up browser resources');\n      }\n    };\n  }\n}; \n"],"mappings":"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","names":[]}