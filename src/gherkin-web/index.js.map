{"version":3,"sources":["../src/cucumber.ts","../src/gherkin.ts","../src/assert.ts"],"sourcesContent":["interface Step {\n  keyword: string;\n  text: string;\n}\n\ninterface CucumberWorld {\n  [key: string]: any;\n}\n\ntype StepImplementation = (this: CucumberWorld, ...args: any[]) => Promise<void> | void;\ntype HookImplementation = (this: CucumberWorld) => Promise<void> | void;\n\ninterface StepStore {\n  given: Map<string, StepImplementation>;\n  when: Map<string, StepImplementation>;\n  then: Map<string, StepImplementation>;\n}\n\ninterface Hooks {\n  before: HookImplementation[];\n  after: HookImplementation[];\n}\n\n\nconst stepStore: StepStore = {\n  given: new Map(),\n  when: new Map(),\n  then: new Map()\n};\n\nconst hooks: Hooks = {\n  before: [],\n  after: []\n};\n\n// Default World class\nexport class World implements CucumberWorld {\n  constructor() {}\n}\n\n// World constructor storage\nlet WorldConstructor: new () => CucumberWorld = World;\n\n// Keep track of the last step type\nlet lastStepType: keyof StepStore = 'given';\n\n// Convert Cucumber expression to regex pattern\nconst convertToRegex = (pattern: string): RegExp => {\n  const regexPattern = pattern\n    .replace(/{string}/g, '\"([^\"]*)\"')\n    .replace(/{(\\w+)}/g, '([^\\\\s]*)');\n  return new RegExp(`^${regexPattern}$`);\n};\n\n// Helper to find matching pattern and extract parameters\nconst findMatchingStep = (store: Map<string, StepImplementation>, text: string) => {\n  for (const [pattern, implementation] of store.entries()) {\n    if (typeof pattern === 'string') {\n      const regex = convertToRegex(pattern);\n      const match = text.match(regex);\n      if (match) {\n        const params = match.slice(1).filter(p => p !== undefined);\n        return { implementation, params };\n      }\n    }\n  }\n  return null;\n};\n\n// Helper to add step definition with context\nconst addStepDefinition = (type: keyof StepStore, pattern: string, implementation: StepImplementation): void => {\n  stepStore[type.toLowerCase() as keyof StepStore].set(pattern, implementation);\n};\n\n// Helper to find and execute step\nconst executeStep = async (context: World, type: string, text: string): Promise<void> => {\n  // Handle 'and' by using the last step type\n  const stepType = type.toLowerCase() === 'and' ? lastStepType : type.toLowerCase() as keyof StepStore;\n  \n  // Update last step type for next 'and'\n  if (type.toLowerCase() !== 'and') {\n    lastStepType = stepType as keyof StepStore;\n  }\n  \n  const store = stepStore[stepType];\n  const match = findMatchingStep(store, text);\n  \n  if (match) {\n    const { implementation, params } = match;\n    await implementation.apply(context, params);\n  } else {\n    console.warn(`No implementation found for ${type} \"${text}\"`);\n  }\n};\n\n// Execute all registered before hooks\nconst executeBefore = async (context: World): Promise<void> => {\n  for (const beforeHook of hooks.before) {\n    await beforeHook.apply(context);\n  }\n};\n\n// Execute all registered after hooks\nconst executeAfter = async (context: World): Promise<void> => {\n  for (const afterHook of hooks.after) {\n    await afterHook.apply(context);\n  }\n};\n\n// Execute a complete scenario with hooks and steps\nexport const executeScenario = async (scenarioName: string, steps: Step[]): Promise<void> => {\n  console.log(`\\nExecuting Scenario: ${scenarioName}`);\n  \n  // Reset last step type at the start of each scenario\n  lastStepType = 'given';\n  \n  // Create context using World constructor\n  const context = new WorldConstructor();\n  \n  // Execute before hooks with shared context\n  await executeBefore(context);\n  \n  try {\n    // Execute scenario steps with shared context\n    for (const step of steps) {\n      const keyword = step.keyword.trim().toLowerCase();\n      await executeStep(context, keyword, step.text);\n    }\n  } finally {\n    // Execute after hooks with shared context (even if steps fail)\n    await executeAfter(context);\n  }\n};\n\n// Set custom World constructor\nexport const setWorldConstructor = (constructor: new () => World): void => {\n  WorldConstructor = constructor;\n};\n\n// Convenience methods for adding steps\nexport const Given = (pattern: string, implementation: StepImplementation): void => \n  addStepDefinition('given', pattern, implementation);\n\nexport const When = (pattern: string, implementation: StepImplementation): void => \n  addStepDefinition('when', pattern, implementation);\n\nexport const Then = (pattern: string, implementation: StepImplementation): void => \n  addStepDefinition('then', pattern, implementation);\n\n// Hook registration methods\nexport const Before = (implementation: HookImplementation): number => {\n  hooks.before.push(implementation);\n  return hooks.before.length;\n};\n\nexport const After = (implementation: HookImplementation): number => {\n  hooks.after.push(implementation);\n  return hooks.after.length;\n}; ","import { Parser, GherkinClassicTokenMatcher, AstBuilder } from '@cucumber/gherkin';\nimport * as messages from '@cucumber/messages';\nimport { executeScenario } from './cucumber';\n\nconst parser = new Parser(\n  new AstBuilder(messages.IdGenerator.uuid()),\n  new GherkinClassicTokenMatcher()\n);\n\nexport async function executeGherkinFeature(featureContent: string): Promise<void> {\n  const gherkinDocument = parser.parse(featureContent);\n  \n  if (!gherkinDocument.feature) {\n    throw new Error('No feature found in Gherkin document');\n  }\n\n  for (const child of gherkinDocument.feature.children) {\n    if (child.scenario) {\n      await executeScenario(child.scenario.name, [...child.scenario.steps]);\n    }\n  }\n} ","const assert = (condition: boolean, message: string = 'Assertion failed') => {\n    console.assert(condition, message);\n  }\n\nassert.strictEqual = <T>(actual: T, expected: T, message: string = 'Values are not strictly equal') => {\n  console.assert(actual === expected, message);\n}\n\nexport default assert;\n\n"],"mappings":"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","names":[]}